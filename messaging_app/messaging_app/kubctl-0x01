#!/usr/bin/env python3
"""
Kubernetes Django App Scaling Script
====================================

This script scales the Django messaging app deployment to 3 replicas,
verifies the pods are running, performs load testing, and monitors resource usage.

Requirements:
- kubectl installed and configured
- wrk load testing tool installed
- Python 3.6+

Usage: python3 kubctl-0x01
"""

import subprocess
import time
import sys
import os


def run_command(command, description=""):
    """
    Execute a shell command and return the result.
    
    Args:
        command (str): The command to execute
        description (str): Description of what the command does
    
    Returns:
        tuple: (success, output, error)
    """
    print(f"\n{'='*50}")
    if description:
        print(f"ğŸ”„ {description}")
    print(f"ğŸ“‹ Running: {command}")
    print(f"{'='*50}")
    
    try:
        result = subprocess.run(
            command, 
            shell=True, 
            capture_output=True, 
            text=True, 
            timeout=60
        )
        
        if result.stdout:
            print("âœ… Output:")
            print(result.stdout)
        
        if result.stderr and result.returncode != 0:
            print("âŒ Error:")
            print(result.stderr)
            return False, result.stdout, result.stderr
        
        return True, result.stdout, result.stderr
        
    except subprocess.TimeoutExpired:
        print("â° Command timed out after 60 seconds")
        return False, "", "Command timed out"
    except Exception as e:
        print(f"ğŸ’¥ Exception occurred: {str(e)}")
        return False, "", str(e)


def check_kubectl():
    """Check if kubectl is installed and accessible."""
    print("ğŸ” Checking if kubectl is available...")
    success, _, _ = run_command("kubectl version --client", "Checking kubectl installation")
    if not success:
        print("âŒ kubectl is not installed or not in PATH")
        print("ğŸ’¡ Please install kubectl and ensure it's configured properly")
        return False
    print("âœ… kubectl is available")
    return True


def scale_deployment():
    """Scale the Django app deployment to 3 replicas."""
    deployment_name = "django-messaging-app"
    replicas = 3
    
    print(f"ğŸš€ Scaling deployment '{deployment_name}' to {replicas} replicas...")
    
    command = f"kubectl scale deployment {deployment_name} --replicas={replicas}"
    success, output, error = run_command(
        command, 
        f"Scaling {deployment_name} to {replicas} replicas"
    )
    
    if not success:
        print(f"âŒ Failed to scale deployment: {error}")
        return False
    
    print(f"âœ… Successfully scaled {deployment_name} to {replicas} replicas")
    return True


def verify_pods():
    """Verify that multiple pods are running."""
    print("ğŸ” Verifying that pods are running...")
    
    # Wait a bit for pods to start
    print("â³ Waiting 30 seconds for pods to start...")
    time.sleep(30)
    
    # Get pods with specific deployment label
    command = "kubectl get pods -l app=django-messaging-app"
    success, output, error = run_command(
        command, 
        "Getting pods for django-messaging-app"
    )
    
    if not success:
        print(f"âŒ Failed to get pods: {error}")
        return False
    
    # Count running pods
    lines = output.strip().split('\n')
    if len(lines) <= 1:  # Only header line
        print("âŒ No pods found")
        return False
    
    running_pods = 0
    for line in lines[1:]:  # Skip header
        if 'Running' in line:
            running_pods += 1
    
    print(f"ğŸ“Š Found {running_pods} running pods")
    
    # Also show general pod status
    run_command("kubectl get pods", "Getting all pods status")
    
    return running_pods >= 3


def perform_load_testing():
    """Perform load testing using wrk if available."""
    print("ğŸ‹ï¸ Performing load testing...")
    
    # First, check if wrk is available
    print("ğŸ” Checking if wrk is available...")
    success, _, _ = run_command("wrk --version", "Checking wrk installation")
    
    if not success:
        print("âš ï¸ wrk is not installed. Skipping load testing.")
        print("ğŸ’¡ To install wrk:")
        print("   - On Ubuntu/Debian: sudo apt-get install wrk")
        print("   - On macOS: brew install wrk")
        print("   - On Windows: Download from https://github.com/wg/wrk")
        return False
    
    # Get service URL - assuming service is exposed
    print("ğŸ” Getting service information...")
    run_command("kubectl get services", "Getting services")
    
    # For demonstration, we'll use a generic load test
    # In real scenario, you'd need to get the actual service endpoint
    service_url = "http://localhost:8000"  # Default Django port
    
    print(f"ğŸš€ Running load test against {service_url}")
    print("ğŸ“ Note: Make sure the service is properly exposed and accessible")
    
    # Run a simple load test: 10 connections, 30 seconds, 2 threads
    command = f"wrk -t2 -c10 -d30s {service_url}/admin/"
    success, output, error = run_command(
        command, 
        f"Load testing {service_url} for 30 seconds"
    )
    
    if success:
        print("âœ… Load testing completed successfully")
    else:
        print("âš ï¸ Load testing encountered issues (this might be expected if service isn't exposed)")
    
    return success


def monitor_resources():
    """Monitor resource usage using kubectl top."""
    print("ğŸ“Š Monitoring resource usage...")
    
    # Check if metrics server is available
    print("ğŸ” Checking metrics server availability...")
    success, _, _ = run_command("kubectl top nodes", "Checking metrics server")
    
    if not success:
        print("âš ï¸ Metrics server is not available or not installed")
        print("ğŸ’¡ To install metrics server:")
        print("   kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml")
        print("ğŸ“ Skipping resource monitoring...")
        return False
    
    # Monitor node resources
    run_command("kubectl top nodes", "Getting node resource usage")
    
    # Monitor pod resources
    run_command("kubectl top pods", "Getting pod resource usage")
    
    # Monitor specific deployment pods
    command = "kubectl top pods -l app=django-messaging-app"
    run_command(command, "Getting django-messaging-app pods resource usage")
    
    return True


def main():
    """Main function to orchestrate the scaling process."""
    print("ğŸ¯ Django App Kubernetes Scaling Script")
    print("=" * 50)
    
    # Step 1: Check prerequisites
    if not check_kubectl():
        sys.exit(1)
    
    # Step 2: Scale the deployment
    if not scale_deployment():
        print("âŒ Failed to scale deployment. Exiting...")
        sys.exit(1)
    
    # Step 3: Verify pods are running
    if not verify_pods():
        print("âš ï¸ Not all pods are running as expected")
    
    # Step 4: Perform load testing
    perform_load_testing()
    
    # Step 5: Monitor resource usage
    monitor_resources()
    
    print("\nğŸ‰ Scaling process completed!")
    print("ğŸ“‹ Summary of actions performed:")
    print("   âœ… Scaled django-messaging-app deployment to 3 replicas")
    print("   âœ… Verified pod status")
    print("   âœ… Attempted load testing (if wrk available)")
    print("   âœ… Monitored resource usage (if metrics server available)")
    
    print("\nğŸ’¡ Useful follow-up commands:")
    print("   - Check pods: kubectl get pods -l app=django-messaging-app")
    print("   - Check deployment: kubectl get deployment django-messaging-app")
    print("   - Scale down: kubectl scale deployment django-messaging-app --replicas=1")
    print("   - Delete deployment: kubectl delete deployment django-messaging-app")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nâ¹ï¸ Script interrupted by user")
        sys.exit(0)
    except Exception as e:
        print(f"\nğŸ’¥ Unexpected error: {str(e)}")
        sys.exit(1)